import React, { useMemo } from "react";
import {
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  Box,
  Stack,
  Chip,
  Tooltip,
  InputAdornment,
  IconButton,
} from "@mui/material";
import LockIcon from "@mui/icons-material/Lock";
import LockOpenIcon from "@mui/icons-material/LockOpen";
import ColorizeIcon from "@mui/icons-material/Colorize";
import ContrastIcon from "@mui/icons-material/Contrast";
import type { ShadeDefinition } from "../types";
import { hexToHsv } from "../utils/colorConversions";
import { calculateContrast } from "../utils/contrastCalculations";

export interface ShadeCardProps {
  shade: ShadeDefinition;
  onUpdate: (updates: Partial<ShadeDefinition>) => void;
  contrastTargetColor?: string | null;
}

const ShadeCard = React.memo(
  function ShadeCard({ shade, onUpdate, contrastTargetColor }: ShadeCardProps) {
    const colorInputRef = React.useRef<HTMLInputElement>(null);
    const [hexInput, setHexInput] = React.useState(shade.color);

    // Sync local hex input with shade.color when shade changes externally
    React.useEffect(() => {
      setHexInput(shade.color);
    }, [shade.color]);

    const contrastWhite = useMemo(
      () => calculateContrast(shade.color, "#ffffff"),
      [shade.color],
    );
    const contrastBlack = useMemo(
      () => calculateContrast(shade.color, "#000000"),
      [shade.color],
    );
    const contrastCustom = useMemo(
      () =>
        contrastTargetColor
          ? calculateContrast(shade.color, contrastTargetColor)
          : null,
      [shade.color, contrastTargetColor],
    );

    const { textColor, isAchromatic } = useMemo(() => {
      const cWhite = contrastWhite;
      const cBlack = contrastBlack;
      return {
        textColor: cWhite > cBlack ? "#fff" : "#000",
        isAchromatic: shade.hsv.s < 1,
      };
    }, [contrastWhite, contrastBlack, shade.hsv.s]);

    const handleColorChange = React.useCallback(
      (newColor: string) => {
        // Normalize to uppercase for consistency
        const normalizedColor = newColor.toUpperCase();
        if (/^#[0-9A-F]{6}$/.test(normalizedColor)) {
          const hsv = hexToHsv(normalizedColor);

          // If the new color is achromatic, preserve the current shade's hue
          // This prevents the hue from being set to 0 and affecting interpolation
          if (hsv.s < 1) {
            hsv.h = shade.hsv.h;
          }

          // Clear extrapolationMethod when user manually edits
          onUpdate({
            color: normalizedColor,
            hsv,
            extrapolationMethod: undefined,
            generationMode: undefined,
          });
        }
      },
      [shade.hsv.h, onUpdate],
    );

    // Note: shade.hsv.h is a primitive value, safe to use in dependencies

    return (
      <Card
        sx={{
          bgcolor: shade.color,
          minHeight: 200,
          display: "flex",
          flexDirection: "column",
          justifyContent: "space-between",
          border: 2,
          borderColor: shade.locked ? "primary.main" : "divider",
          position: "relative", // For absolute positioning of badge
        }}
      >
        {/* Top Right Chip Container */}
        <Box
          sx={{
            position: "absolute",
            top: 8,
            right: 8,
            zIndex: 1,
            display: "flex",
            flexDirection: "row",
            gap: 0.5,
            alignItems: "flex-start",
            flexWrap: "wrap",
            justifyContent: "flex-end",
            maxWidth: "calc(100% - 16px)", // Prevent overflow beyond card bounds
          }}
        >
          {/* Extrapolation Method Badge */}
          {!shade.locked && shade.extrapolationMethod && (
            <Tooltip
              title={
                shade.extrapolationMethod === "interpolated"
                  ? "Generated by interpolating between locked shades"
                  : shade.extrapolationMethod === "linear"
                  ? "Generated by extending the color curve linearly"
                  : shade.extrapolationMethod === "adjusted"
                  ? shade.generationMode === "functional"
                    ? "Generated using UI-optimized curves (trending toward white/black)"
                    : "Generated using adjusted curves to prevent invalid colors"
                  : ""
              }
              placement="top"
            >
              <Chip
                label={
                  shade.extrapolationMethod === "interpolated"
                    ? "Interpolated"
                    : shade.extrapolationMethod === "linear"
                    ? "Extrapolated"
                    : shade.extrapolationMethod === "adjusted"
                    ? shade.generationMode === "functional"
                      ? "UI Mode"
                      : "Adjusted"
                    : ""
                }
                size="small"
                color={
                  shade.extrapolationMethod === "adjusted" &&
                  shade.generationMode === "expressive"
                    ? "warning" // Yellow warning in expressive mode (indicates fallback)
                    : "info" // Blue info badge otherwise
                }
              />
            </Tooltip>
          )}

          {/* Achromatic Indicator Badge */}
          {isAchromatic && (
            <Tooltip
              title="This color has very low saturation (S < 1) and is considered achromatic (neutral). Its hue won't affect interpolation between other colors."
              placement="top"
            >
              <Chip
                label="Achromatic"
                size="small"
                variant="filled"
                color="neutral"
              />
            </Tooltip>
          )}
        </Box>

        <CardContent sx={{ flexGrow: 1 }}>
          <Typography
            variant="h5"
            component="div"
            sx={{
              color: textColor,
              mb: 1,
            }}
          >
            {shade.label}
          </Typography>

          <TextField
            value={hexInput}
            onChange={(e) => {
              const newColor = e.target.value.toUpperCase();

              // Allow typing only valid hex characters
              if (/^#[0-9A-F]{0,6}$/.test(newColor) || newColor === "") {
                setHexInput(newColor);

                // Only update parent state if we have a complete valid hex color
                if (/^#[0-9A-F]{6}$/.test(newColor)) {
                  handleColorChange(newColor);
                }
              }
            }}
            onBlur={() => {
              // On blur, reset to valid color if input is invalid
              if (!/^#[0-9A-F]{6}$/.test(hexInput)) {
                setHexInput(shade.color);
              }
            }}
            size="small"
            fullWidth
            slotProps={{
              input: {
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="Pick color"
                      onClick={() => colorInputRef.current?.click()}
                      edge="end"
                      size="small"
                      sx={{ color: textColor }}
                    >
                      <ColorizeIcon fontSize="small" />
                    </IconButton>
                  </InputAdornment>
                ),
              },
            }}
            sx={{
              mb: 1,
              "& .MuiInputBase-input": {
                fontFamily: "monospace",
                fontSize: "0.75rem",
                color: textColor, // Use calculated text color for proper contrast
              },
              "& .MuiOutlinedInput-root": {
                "& fieldset": {
                  borderColor: textColor, // Border matches contrast text color
                  opacity: 0.8,
                },
                "&:hover fieldset": {
                  borderColor: textColor,
                  opacity: 0.9,
                },
                "&.Mui-focused fieldset": {
                  borderColor: textColor,
                  opacity: 1,
                },
              },
            }}
          />

          {/* Hidden native color picker input */}
          <Box
            component="input"
            type="color"
            value={shade.color}
            onChange={(e) => handleColorChange(e.target.value)}
            ref={colorInputRef}
            sx={{
              position: "absolute",
              opacity: 0,
              width: 0,
              height: 0,
              pointerEvents: "none",
            }}
          />

          <Typography
            variant="caption"
            sx={{
              color: textColor,
              opacity: 0.7,
              fontFamily: "monospace",
              display: "block",
            }}
          >
            H:{Math.round(shade.hsv.h)} S:{Math.round(shade.hsv.s)} V:
            {Math.round(shade.hsv.v)}
          </Typography>
        </CardContent>

        <CardContent sx={{ pt: 0 }}>
          <Stack spacing={0.5} sx={{ mb: 1 }}>
            {/* White contrast line */}
            <Stack direction="row" spacing={0.5} alignItems="center">
              <Typography
                variant="caption"
                sx={{ color: textColor, opacity: 0.8, minWidth: 80 }}
              >
                White: {contrastWhite.toFixed(2)}
              </Typography>
              {contrastWhite >= 7 && (
                <Tooltip title="Meets WCAG AAA standard (7:1 contrast ratio) - excellent for all text">
                  <Chip label="AAA" size="small" color="success" />
                </Tooltip>
              )}
              {contrastWhite >= 4.5 && contrastWhite < 7 && (
                <Tooltip title="Meets WCAG AA standard (4.5:1 contrast ratio) - good for normal text">
                  <Chip label="AA" size="small" color="primary" />
                </Tooltip>
              )}
            </Stack>

            {/* Black contrast line */}
            <Stack direction="row" spacing={0.5} alignItems="center">
              <Typography
                variant="caption"
                sx={{ color: textColor, opacity: 0.8, minWidth: 80 }}
              >
                Black: {contrastBlack.toFixed(2)}
              </Typography>
              {contrastBlack >= 7 && (
                <Tooltip title="Meets WCAG AAA standard (7:1 contrast ratio) - excellent for all text">
                  <Chip label="AAA" size="small" color="success" />
                </Tooltip>
              )}
              {contrastBlack >= 4.5 && contrastBlack < 7 && (
                <Tooltip title="Meets WCAG AA standard (4.5:1 contrast ratio) - good for normal text">
                  <Chip label="AA" size="small" color="primary" />
                </Tooltip>
              )}
            </Stack>

            {/* Custom contrast line (only if custom color is set) */}
            {contrastTargetColor && contrastCustom !== null && (
              <Stack direction="row" spacing={0.5} alignItems="center">
                <ContrastIcon
                  sx={{
                    fontSize: "0.875rem",
                    color: contrastTargetColor,
                  }}
                />
                <Typography
                  variant="caption"
                  sx={{ color: textColor, opacity: 0.8, minWidth: 80 }}
                >
                  {contrastTargetColor}: {contrastCustom.toFixed(2)}
                </Typography>
                {contrastCustom >= 7 && (
                  <Tooltip title="Meets WCAG AAA standard (7:1 contrast ratio) - excellent for all text">
                    <Chip label="AAA" size="small" color="success" />
                  </Tooltip>
                )}
                {contrastCustom >= 4.5 && contrastCustom < 7 && (
                  <Tooltip title="Meets WCAG AA standard (4.5:1 contrast ratio) - good for normal text">
                    <Chip label="AA" size="small" color="primary" />
                  </Tooltip>
                )}
              </Stack>
            )}
          </Stack>

          <Button
            fullWidth
            variant="contained"
            size="small"
            color={shade.locked ? "primary" : "secondary"}
            startIcon={
              shade.locked ? (
                <LockIcon fontSize="small" />
              ) : (
                <LockOpenIcon fontSize="small" />
              )
            }
            onClick={() => {
              const newLockedState = !shade.locked;
              onUpdate({
                locked: newLockedState,
                // Keep all channels selected/visible
                selectedForH: true,
                selectedForS: true,
                selectedForV: true,
              });
            }}
          >
            {shade.locked ? "Locked" : "Unlocked"}
          </Button>
        </CardContent>
      </Card>
    );
  },
  (prevProps, nextProps) => {
    // Only re-render if shade data actually changed
    const prev = prevProps.shade;
    const next = nextProps.shade;

    return (
      prev.id === next.id &&
      prev.color === next.color &&
      prev.label === next.label &&
      prev.locked === next.locked &&
      prev.extrapolationMethod === next.extrapolationMethod &&
      prev.generationMode === next.generationMode &&
      prev.hsv.h === next.hsv.h &&
      prev.hsv.s === next.hsv.s &&
      prev.hsv.v === next.hsv.v &&
      prevProps.contrastTargetColor === nextProps.contrastTargetColor
    );
  },
);

export default ShadeCard;
